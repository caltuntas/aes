#include "test-framework/unity.h"
#include "key_schedule.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#define ARRAY_LEN(arr) (sizeof(arr)/sizeof(arr[0]))

void setUp(void)
{
}

void tearDown(void)
{
}

static void test_rot_word(void)
{
  uint32_t actual = convert_to_uint32((uint8_t[4]){0x09,0xcf,0x4f,0x3c});
  uint32_t expected = convert_to_uint32((uint8_t[4]){0xcf,0x4f,0x3c,0x09});
  uint32_t res = rot_word(actual);
  TEST_ASSERT_EQUAL_INT(res,expected);
}

static void test_sub_word(void)
{
  uint32_t actual = convert_to_uint32((uint8_t[4]){0xcf,0x4f,0x3c,0x09});
  uint32_t expected = convert_to_uint32((uint8_t[4]){0x8a,0x84,0xeb,0x01});
  uint32_t res = sub_word(actual);
  TEST_ASSERT_EQUAL_INT(res,expected);
}

static void test_rcon(void)
{
  TEST_ASSERT_EQUAL_INT(rcon(1,convert_to_uint32((uint8_t[4]){0x8a,0x84,0xeb,0x01})),
      convert_to_uint32((uint8_t[4]){0x8b,0x84,0xeb,0x01}));
  TEST_ASSERT_EQUAL_INT(rcon(2,convert_to_uint32((uint8_t[4]){0x8a,0x84,0xeb,0x01})),
      convert_to_uint32((uint8_t[4]){0x88,0x84,0xeb,0x01}));
  TEST_ASSERT_EQUAL_INT(rcon(9,convert_to_uint32((uint8_t[4]){0x8a,0x84,0xeb,0x01})),
      convert_to_uint32((uint8_t[4]){0x91,0x84,0xeb,0x01}));
}

static void test_expand_key(void)
{
  uint8_t key[16]={0x2b,0x7e,0x15,0x16,0x28,0xae,0xd2,0xa6,0xab,0xf7,0x15,0x88,0x09,0xcf,0x4f,0x3c};

  uint8_t round_keys[11][16] = {
    {0x2b,0x7e,0x15,0x16,0x28,0xae,0xd2,0xa6,0xab,0xf7,0x15,0x88,0x09,0xcf,0x4f,0x3c},
    {0xa0,0xfa,0xfe,0x17,0x88,0x54,0x2c,0xb1,0x23,0xa3,0x39,0x39,0x2a,0x6c,0x76,0x05},
    {0xf2,0xc2,0x95,0xf2,0x7a,0x96,0xb9,0x43,0x59,0x35,0x80,0x7a,0x73,0x59,0xf6,0x7f},
    {0x3d,0x80,0x47,0x7d,0x47,0x16,0xfe,0x3e,0x1e,0x23,0x7e,0x44,0x6d,0x7a,0x88,0x3b},
    {0xef,0x44,0xa5,0x41,0xa8,0x52,0x5b,0x7f,0xb6,0x71,0x25,0x3b,0xdb,0x0b,0xad,0x00},
    {0xd4,0xd1,0xc6,0xf8,0x7c,0x83,0x9d,0x87,0xca,0xf2,0xb8,0xbc,0x11,0xf9,0x15,0xbc},
    {0x6d,0x88,0xa3,0x7a,0x11,0x0b,0x3e,0xfd,0xdb,0xf9,0x86,0x41,0xca,0x00,0x93,0xfd},
    {0x4e,0x54,0xf7,0x0e,0x5f,0x5f,0xc9,0xf3,0x84,0xa6,0x4f,0xb2,0x4e,0xa6,0xdc,0x4f},
    {0xea,0xd2,0x73,0x21,0xb5,0x8d,0xba,0xd2,0x31,0x2b,0xf5,0x60,0x7f,0x8d,0x29,0x2f},
    {0xac,0x77,0x66,0xf3,0x19,0xfa,0xdc,0x21,0x28,0xd1,0x29,0x41,0x57,0x5c,0x00,0x6e},
    {0xd0,0x14,0xf9,0xa8,0xc9,0xee,0x25,0x89,0xe1,0x3f,0x0c,0xc8,0xb6,0x63,0x0c,0xa6},
  };

  for (int i=0; i<11; i++) {
    uint8_t *expected=round_keys[i];
    expand_key(i,key);
    TEST_ASSERT_EQUAL_HEX8_ARRAY(expected,key,16);
  }
}

static void test_convert(void)
{
  uint32_t actual = convert_to_uint32((uint8_t[4]){0x09,0xcf,0x4f,0x3c});
  uint8_t arr[4] = {0};
  convert_to_uint8_array(actual,arr);
  uint8_t expected[] ={0x09,0xcf,0x4f,0x3c};
  uint32_t res = rot_word(actual);
  TEST_ASSERT_EQUAL_HEX8_ARRAY(expected,arr,4);
}

static void test_add_round_key(void)
{
  uint8_t key[16]={0x2b,0x7e,0x15,0x16,0x28,0xae,0xd2,0xa6,0xab,0xf7,0x15,0x88,0x09,0xcf,0x4f,0x3c};
  uint8_t text[16]={0x32,0x43,0xf6,0xa8,0x88,0x5a,0x30,0x8d,0x31,0x31,0x98,0xa2,0xe0,0x37,0x07,0x34};
  uint8_t expected[16]={0x19,0x3d,0xe3,0xbe,0xa0,0xf4,0xe2,0x2b,0x9a,0xc6,0x8d,0x2a,0xe9,0xf8,0x48,0x08};
  expand_key(0,key);
  add_round_key(text,key,16);
  TEST_ASSERT_EQUAL_HEX8_ARRAY(expected,text,16);
}

static void test_sub_bytes(void)
{
  uint8_t state[16]={0x19,0x3d,0xe3,0xbe,0xa0,0xf4,0xe2,0x2b,0x9a,0xc6,0x8d,0x2a,0xe9,0xf8,0x48,0x08};
  uint8_t expected[16]={0xd4,0x27,0x11,0xae,0xe0,0xbf,0x98,0xf1,0xb8,0xb4,0x5d,0xe5,0x1e,0x41,0x52,0x30};
  sub_bytes(state,16);
  TEST_ASSERT_EQUAL_HEX8_ARRAY(expected,state,16);
}

static void test_inv_sub_bytes(void)
{
  uint8_t state[16]={0xd4,0x27,0x11,0xae,0xe0,0xbf,0x98,0xf1,0xb8,0xb4,0x5d,0xe5,0x1e,0x41,0x52,0x30};
  uint8_t expected[16]={0x19,0x3d,0xe3,0xbe,0xa0,0xf4,0xe2,0x2b,0x9a,0xc6,0x8d,0x2a,0xe9,0xf8,0x48,0x08};
  uint8_t res[16] = {0};
  inv_sub_bytes(state,res);
  TEST_ASSERT_EQUAL_HEX8_ARRAY(expected,res,16);
}

static void test_shift_rows(void)
{
  uint8_t state[16]={
    0xd4,0x27,0x11,0xae, //col 1
    0xe0,0xbf,0x98,0xf1, //col 2
    0xb8,0xb4,0x5d,0xe5, //col 3
    0x1e,0x41,0x52,0x30  //col 4
  };
  uint8_t expected[16]={
    0xd4,0xbf,0x5d,0x30, //col 1
    0xe0,0xb4,0x52,0xae, //col 2
    0xb8,0x41,0x11,0xf1, //col 3
    0x1e,0x27,0x98,0xe5  //col 4
  };
  shift_rows(state,16);
  TEST_ASSERT_EQUAL_HEX8_ARRAY(expected,state,16);
}

static void test_inv_shift_rows(void)
{
  uint8_t expected[16]={
    0xd4,0x27,0x11,0xae,   //col 1
    0xe0,0xbf,0x98,0xf1,   //col 2
    0xb8,0xb4,0x5d,0xe5,   //col 3
    0x1e,0x41,0x52,0x30    //col 4
  };
  uint8_t state[16]={
    0xd4,0xbf,0x5d,0x30,   //col 1
    0xe0,0xb4,0x52,0xae,   //col 2
    0xb8,0x41,0x11,0xf1,   //col 3
    0x1e,0x27,0x98,0xe5    //col 4
  };
  uint8_t res[16] = {0};
  inv_shift_rows(state,res);
  TEST_ASSERT_EQUAL_HEX8_ARRAY(expected,res,16);
}

static void test_mix_columns(void)
{
  uint8_t state[16]={
    0xd4,0xbf,0x5d,0x30, //col 1
    0xe0,0xb4,0x52,0xae, //col 2
    0xb8,0x41,0x11,0xf1, //col 3
    0x1e,0x27,0x98,0xe5  //col 4
  };
  uint8_t expected[16]={
    0x04,0x66,0x81,0xe5,  //col 1
    0xe0,0xcb,0x19,0x9a,  //col 2
    0x48,0xf8,0xd3,0x7a,  //col 3
    0x28,0x06,0x26,0x4c   //col 4
  };
  mix_columns(state);
  TEST_ASSERT_EQUAL_HEX8_ARRAY(expected,state,16);
}

static void test_inv_mix_columns(void)
{
  uint8_t state[16]={
    0x04,0x66,0x81,0xe5, //col 1
    0xe0,0xcb,0x19,0x9a, //col 2
    0x48,0xf8,0xd3,0x7a, //col 3
    0x28,0x06,0x26,0x4c  //col 4
  };
  uint8_t expected[16]={
    0xd4,0xbf,0x5d,0x30, //col 1
    0xe0,0xb4,0x52,0xae, //col 2
    0xb8,0x41,0x11,0xf1, //col 3
    0x1e,0x27,0x98,0xe5  //col 4
  };
  uint8_t res[16] = {0};
  inv_mix_columns(state,res);
  TEST_ASSERT_EQUAL_HEX8_ARRAY(expected,res,16);
}

static void test_round(void)
{
  uint8_t key[16]={0xa0,0xfa,0xfe,0x17,0x88,0x54,0x2c,0xb1,0x23,0xa3,0x39,0x39,0x2a,0x6c,0x76,0x05,};
  uint8_t state[16]={
    0x19,0x3d,0xe3,0xbe, //column 1
    0xa0,0xf4,0xe2,0x2b, //column 2
    0x9a,0xc6,0x8d,0x2a, //column 3
    0xe9,0xf8,0x48,0x08  //column 4
  };
  uint8_t expected[16]={
    0xa4,0x9c,0x7f,0xf2, //column 1
    0x68,0x9f,0x35,0x2b, //column 2
    0x6b,0x5b,0xea,0x43, //column 3
    0x02,0x6a,0x50,0x49  //column 4
  };
  uint8_t res[16] = {0};
  aes_round(state,key, res);
  TEST_ASSERT_EQUAL_HEX8_ARRAY(expected,res,16);
}

static void test_dec_round(void)
{
  //round=6 check values from https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.197-upd1.pdf
  //Appendix B â€” Cipher Example
  uint8_t key[16] = {
    0x6d,0x88,0xa3,0x7a, // col 1
    0x11,0x0b,0x3e,0xfd, // col 2
    0xdb,0xf9,0x86,0x41, // col 3
    0xca,0x00,0x93,0xfd  // col 4
  };

  uint8_t state[16] = {
    0xf7,0x83,0x40,0x3f,  // col 1
    0x27,0x43,0x3d,0xf0,  // col 2
    0x9b,0xb5,0x31,0xff,  // col 3
    0x54,0xab,0xa9,0xd3   // col 4
  };

  uint8_t expected[16] = {
    0xa1,0x4f,0x3d,0xfe,   // col 1
    0x78,0xe8,0x03,0xfc,   // col 2
    0x10,0xd5,0xa8,0xdf,   // col 3
    0x4c,0x63,0x29,0x23    // col 4
  };

  uint8_t res[16] = {0};
  aes_dec_round(state, key, res);
  TEST_ASSERT_EQUAL_HEX8_ARRAY(expected, res, 16);
}

static void test_final_round(void)
{
  uint8_t state[16] = {
    0xeb,0x40,0xf2,0x1e,  // col 0
    0x59,0x2e,0x38,0x84,  // col 1
    0x8b,0xa1,0x13,0xe7,  // col 2
    0x1b,0xc3,0x42,0xd2,  // col 3
  };
  uint8_t key[16] = {
    0xd0,0x14,0xf9,0xa8,  // col 0
    0xc9,0xee,0x25,0x89,  // col 1
    0xe1,0x3f,0x0c,0xc8,  // col 2
    0xb6,0x63,0x0c,0xa6   // col 3
  };
  uint8_t expected[16] = {
    0x39,0x25,0x84,0x1d,  // col 0
    0x02,0xdc,0x09,0xfb,  // col 1
    0xdc,0x11,0x85,0x97,  // col 2
    0x19,0x6a,0x0b,0x32   // col 3
  };
  uint8_t res[16] = {0};
  aes_final_round(state, key, res);
  TEST_ASSERT_EQUAL_HEX8_ARRAY(expected, res, 16);
}

static void test_aes_enc(void)
{
  uint8_t key[16]={
    0x2b,0x7e,0x15,0x16,
    0x28,0xae,0xd2,0xa6,
    0xab,0xf7,0x15,0x88,
    0x09,0xcf,0x4f,0x3c
  };
  uint8_t text[16]={
    0x32,0x43,0xf6,0xa8,
    0x88,0x5a,0x30,0x8d,
    0x31,0x31,0x98,0xa2,
    0xe0,0x37,0x07,0x34
  };
  uint8_t expected[16] = {
    0x39,0x25,0x84,0x1d,  // col 0
    0x02,0xdc,0x09,0xfb,  // col 1
    0xdc,0x11,0x85,0x97,  // col 2
    0x19,0x6a,0x0b,0x32   // col 3
  };
  uint8_t res[16] = {0};
  aes_enc(text, key, res);
  TEST_ASSERT_EQUAL_HEX8_ARRAY(expected, res, 16);
}

static void test_aes_dec(void)
{
  uint8_t key[16]={
    0x2b,0x7e,0x15,0x16,
    0x28,0xae,0xd2,0xa6,
    0xab,0xf7,0x15,0x88,
    0x09,0xcf,0x4f,0x3c
  };
  uint8_t expected[16]={
    0x32,0x43,0xf6,0xa8,
    0x88,0x5a,0x30,0x8d,
    0x31,0x31,0x98,0xa2,
    0xe0,0x37,0x07,0x34
  };
  uint8_t cipher_text[16] = {
    0x39,0x25,0x84,0x1d,  // col 0
    0x02,0xdc,0x09,0xfb,  // col 1
    0xdc,0x11,0x85,0x97,  // col 2
    0x19,0x6a,0x0b,0x32   // col 3
  };
  uint8_t res[16] = {0};
  aes_dec(cipher_text, key, res);
  TEST_ASSERT_EQUAL_HEX8_ARRAY(expected, res, 16);
}

static void test_add_round_key_10(void)
{
  uint8_t cipher_text[16] = {
    0x39,0x25,0x84,0x1d,  // col 0
    0x02,0xdc,0x09,0xfb,  // col 1
    0xdc,0x11,0x85,0x97,  // col 2
    0x19,0x6a,0x0b,0x32   // col 3
  };
  uint8_t round10_key[16] = {
    0xd0, 0x14, 0xf9, 0xa8,
    0xc9, 0xee, 0x25, 0x89,
    0xe1, 0x3f, 0x0c, 0xc8,
    0xb6, 0x63, 0x0c, 0xa6
  };
  uint8_t expected[16]={
    0xe9,0x31,0x7d,0xb5,
    0xcb,0x32,0x2c,0x72,
    0x3d,0x2e,0x89,0x5f,
    0xaf,0x09,0x07,0x94
  };
  add_round_key(cipher_text,round10_key,16);
  TEST_ASSERT_EQUAL_HEX8_ARRAY(expected,cipher_text,16);
}

static void test_mul(void) 
{
  uint8_t cases[17][3]= {
    {0x01 , 0x01 , 0x01},
    {0x01 , 0xFF , 0xFF},
    {0x00 , 0x57 , 0x00},
    {0x57 , 0x00 , 0x00},
    {0x02 , 0x02 , 0x04},
    {0x02 , 0x04 , 0x08},
    {0x02 , 0x08 , 0x10},
    {0x02 , 0x10 , 0x20},
    {0x02 , 0x20 , 0x40},
    {0x02 , 0x40 , 0x80},
    {0x02 , 0x80 , 0x1B},
    {0x40 , 0x83 , 0x8D},
    {0x57 , 0x83 , 0xC1},
    {0x57 , 0x13 , 0xFE},
    {0x0D , 0x0E , 0x46},
    {0x0B , 0x0D , 0x7F},
    {0xF1 , 0x03 , 0x08}
  };

  int len = ARRAY_LEN(cases);
  for (int i=0; i<len; i++) {
    uint8_t *row = cases[i];
    uint8_t res = mul(row[0],row[1]);
    char msg[40];
    snprintf(msg,20,"item=%d, %xx%x\n",i,row[0],row[1]);
    TEST_ASSERT_EQUAL_HEX_MESSAGE(row[2],res,msg);
  }
}


int main(void)
{
  UNITY_BEGIN();
  RUN_TEST(test_rot_word);
  RUN_TEST(test_sub_word);
  RUN_TEST(test_rcon);
  RUN_TEST(test_convert);
  RUN_TEST(test_expand_key);
  RUN_TEST(test_add_round_key);
  RUN_TEST(test_sub_bytes);
  RUN_TEST(test_inv_sub_bytes);
  RUN_TEST(test_shift_rows);
  RUN_TEST(test_inv_shift_rows);
  RUN_TEST(test_mix_columns);
  RUN_TEST(test_inv_mix_columns);
  RUN_TEST(test_round);
  RUN_TEST(test_final_round);
  RUN_TEST(test_aes_enc);
  RUN_TEST(test_add_round_key_10);
  RUN_TEST(test_mul);
  RUN_TEST(test_dec_round);
  RUN_TEST(test_aes_dec);
  return UNITY_END();
}
